
// Generated by Tramway SDK Code generator

#include "progresscontroller.h"
#include "progresscontroller.inl"

#include <framework/event.h>
#include <framework/message.h>

#include <framework/ui.h>
#include <render/render.h>

#include <framework/gui.h>
#include <extensions/menu/menu.h>

#include <framework/script.h>

#include <iostream>
#include <string>

static ProgressController* controller = nullptr;

static std::vector<name_t> variable_debugs;
static bool debugs = false;

ProgressController::ProgressController() : Entity("progress") {
	frame.make(Event::FRAME, this);
	keypress.make(Event::KEYPRESS, this);
	
	auto comp = PoolProxy<RenderComponent>::New();
	comp->SetParent(this);
	comp->SetModel("dev/light");
	comp->SetLocation({-5, 5, 16});
	comp->Init();
	
	Script::SetFunction("ResetProgressState", {}, [](valuearray_t array) -> value_t {
		return variable_debugs.clear(), true;
	});
	
	Script::SetFunction("VariableDebug", {TYPE_NAME}, [](valuearray_t array) -> value_t {
		return variable_debugs.push_back(array[0]), true;
	});
	
	Script::SetFunction("SetNPCDialog", {TYPE_STRING}, [](valuearray_t array) -> value_t {
		return controller->SetNPCDialog((const char*)array[0]), true;
	});
	
	Script::SetFunction("SetNPCCallback", {TYPE_NAME}, [](valuearray_t array) -> value_t {
		return controller->SetNPCCallback(array[0]), true;
	});
	
	Script::SetFunction("SetNotification", {TYPE_STRING}, [](valuearray_t array) -> value_t {
		return controller->SetNotification((const char*)array[0]), true;
	});
	
	Script::SetFunction("SetNotificationCallback", {TYPE_NAME}, [](valuearray_t array) -> value_t {
		return controller->SetNotificationCallback(array[0]), true;
	});
	
	Script::SetFunction("SetItemDisplay", {TYPE_STRING, TYPE_NAME}, [](valuearray_t array) -> value_t {
		return controller->SetItemDisplay((const char*)array[0], array[1]), true;
	});
	
	UI::BindKeyboardKey(UI::KEY_H, [](){
		Script::CallFunction("Hint", {});
	});
	
	UI::BindKeyboardKey(UI::KEY_P, [](){
		debugs = !debugs;
	});
}

void ProgressController::Init() {
    controller = new ProgressController;
}

name_t ProgressController::GetType() {
    ENTITY_IMPLEMENTATION_GET_TYPE
}

void ProgressController::UpdateParameters() {
	if (!IsLoaded()) return;
}

void ProgressController::SetParameters() {
	if (!IsLoaded()) return;
	
	UpdateParameters();
}

void ProgressController::Load() {
	SetFlag(LOADED, true);
}

void ProgressController::Unload() {
	SetFlag(LOADED, false);
}

void ProgressController::Serialize() {

}

/// Draws text to screen as dialog.
void ProgressController::SetNPCDialog(std::string dialog) {
	static uint32_t last_dialog = 0;
	// this should limit NPC dialogs queued up to 3 + any other dialogs that get
	// added during the same tick, which should prevent any NPC's dialog from
	// getting cut off
	if (npc_queue.size() < 3 || last_dialog == GetTick()) {
		npc_queue.emplace(dialog);
	}
	last_dialog = GetTick();
}

void ProgressController::SetNPCCallback(name_t callback) {
	npc_callback = callback;
}

void ProgressController::SetNotificationCallback(name_t callback) {
	notif_callback = callback;
}

/// Draws text to screen as a notification.
void ProgressController::SetNotification(std::string notif) {
	static uint32_t last_notification = 0;
	// same as SetNPCDialog()
	if (notif_queue.size() < 3 || last_notification == GetTick()) {
		notif_queue.emplace(notif);
	}
	last_notification = GetTick();
}

/// Shows a spinning item notification.
void ProgressController::SetItemDisplay(std::string text, name_t model) {
	item_model.make();
	item_animation.make();
	
	item_model->SetParent(this);
	item_model->SetModel(model);
	item_model->SetLayer(2);
	
	if (model == "item/scooter" || model == "item/giblets" || model == "item/key") {
		item_model->SetLocation({0, 0, -2});
	} else {
		item_model->SetLocation({0, 0, -1});
	}
	
	item_model->Init();
	
	item_animation->SetParent(this);
	item_animation->SetModel(model);
	item_animation->Init();
	
	item_animation->Play("item-rotate", -1, 1.0f, 1.0f);
	
	item_model->SetArmature(item_animation);
	
	notif_queue.emplace(text, true);
}

// helpers for debug text
static std::string flag_helper(const char* text, bool value) {
	std::string result = text;
	while (result.length() < 21) result += " ";
	result += " [";
	if (value) result += "X";
	if (!value) result += "_";
	result += "]";
	return result;
}

static std::string flag_helper(const char* text, int value) {
	std::string result = text;
	while (result.length() < 21) result += " ";
	result += " [";
	result += std::to_string(value);
	result += "]";
	return result;
} 

void ProgressController::EventHandler(Event& evt) {
	switch (evt.type) {
		case Event::FRAME: {
			
			// draw the debug text in the top left corner
			if (debugs) {
				std::string text = "Nightmare Exploration Simulator v1.0";
				
				vec3 ploc = Entity::Find("player")->GetLocation();
				text += std::string("\nPosition: ") + std::to_string(ploc.x) + " "
													+ std::to_string(ploc.y) + " "
													+ std::to_string(ploc.z);
				
				text += "\nToggle this menu by pressing [P] key";
				
				if (ploc.y < -10.0f) {
					Entity::Find("player")->SetLocation(Entity::Find("player-start")->GetLocation());
				}
				
				for (auto variable : variable_debugs) {
					value_t value = Script::GetGlobal(variable);
					text += "\n";
					
					if (value.IsInt()) {
						text += flag_helper(variable, value.GetInt());
					} else {
						text += flag_helper(variable, (bool)value);
					}
				}
				
				if (UI::GetInputState() != UI::STATE_MENU_OPEN) {
					Render::AddText(5, 0, text.c_str());
				}
			}
			
			
			// draw the NPC dialogs
			
			if (npc_queue.size()) {
				if (npc_queue.front().IsEnd()) {
					npc_queue.pop();
				} else {
					GUI::PushFrameRelative(GUI::FRAME_BOTTOM, 100);
						GUI::SetFont(Ext::Menu::FONT_PIXELART, GUI::TEXT);
						GUI::Text(npc_queue.front().GetText().c_str(), GUI::TEXT_CENTER);
						GUI::RestoreFont();
					GUI::PopFrame();
				}
			} else if (npc_callback) {
				Script::CallFunction("ScriptProgress", {npc_callback});
				npc_callback = "none";
			}
			
			// draw the notifications
			
			if (notif_queue.size()) {
				if (notif_queue.front().IsEnd()) {
					notif_queue.pop();
				} else {
					GUI::PushFrameRelative(GUI::FRAME_BOTTOM, 100);
						GUI::SetFont(Ext::Menu::FONT_PIXELART, GUI::TEXT);
						GUI::Text(notif_queue.front().GetText().c_str(), GUI::TEXT_CENTER);
						GUI::RestoreFont();
					GUI::PopFrame();
				}
			} else if (notif_callback) {
				Script::CallFunction("ScriptProgress", {notif_callback});
				notif_callback = "none";
			}
			
		} break;
		case Event::KEYPRESS:
			if (evt.subtype == UI::KEY_ACTION_JUMP && item_model) {
				item_model.clear();
				item_animation.clear();
				
				while (notif_queue.size()) notif_queue.pop();
			}
			break;
		default:
			std::cout << "Progress unrecognized event: " << Event::GetName(evt.type) << std::endl; 
	}
}

void ProgressController::MessageHandler(Message& msg) {
	if (msg.type != Message::PING) return;
	
	name_t type = *msg.data_value;
	
	Script::CallFunction("ScriptProgress", {type});
}
	